\section{语言与范式}
\subsection{默认采用\{\}初始化}
现代C++变量的初始化应该优先用\{\}，完美兼容所有类型的变量。
这么做并不是特别必要，但是有一种麦克斯韦光、电、磁统一的美感。

\begin{lstlisting}[language=C++]
    std::vector<int> v{ 1, 3, 5 }; 
\end{lstlisting}

\begin{lstlisting}[language=C++]
    double x, y, z;
    int sum1{ x + y + z }; // 报错，一定要是int！
    int sum2(x + y + z); // okay，隐式转成int了!
    int sum3 = x + y + z; // 同上！
\end{lstlisting}

\begin{lstlisting}[language=C++]
    Widget w2(); // 定义了一个函数，雪崩！
    Widget w2{}; // 调用ctor舒适化！
\end{lstlisting}

类对象要注意，如果存在参数为initializer list的ctor，则\{\}初始化必然会优先调这个ctor，没有才会调普通ctor。所以自己写的代码干脆禁用initializer list，免得它劫持\{\}初始化，给人造成误解。vector里就定义了initializer list，使得()与\{\}相同参数初始化意义不同！

\begin{lstlisting}[language=C++]
std::vector<int> v1(10, 20); // 创建10个值为20的元素
std::vector<int> v2{10, 20}; // 创建两个元素：10, 20
\end{lstlisting}


\subsection{使用alias，不用typedef}

下面这种写起来长度差不多。
\begin{lstlisting}[language=C++]
typedef void (*FP)(int, const std::string&); // typedef
using FP = void (*)(int, const std::string&); // alias
\end{lstlisting}

但涉及template时，typedef根本不支持，要耍一个花招，加一层struct做包装。
\begin{lstlisting}[language=C++]
    template<typename T> 
    using MyAllocList = std::list<T, MyAlloc<T>>; 
    MyAllocList<Widget> lw; // client code

    template<typename T> // MyAllocList<T>::type
    struct MyAllocList { 
     typedef std::list<T, MyAlloc<T>> type; 
    }; 
    MyAllocList<Widget>::type lw; // client code
\end{lstlisting}
    


\subsection{使用enum class，少用enum}
\begin{lstlisting}[language=C++]
    enum Color { black, white, red }; // 虽在花括号内，实则定义在外层代码块里。
    auto white = false; // 错了，white已被定义！

    enum class Color { black, white, red }; // 虽在花括号内，实则定义在外层代码块里。
    auto white = false; // 没问题！
    auto c = Color::white; // 正确！
\end{lstlisting}

enum class是强类型enum，有自己的作用域，禁止隐式类型转换，还允许"enum class Color;"这样的前置声明。

此外，enum class内部的默认类型是int，也可以自己设定更合适的类型。
\begin{lstlisting}[language=C++]
    enum class Status: std::uint32_t { 
        good = 0,
        failed = 1,
        incomplete = 100,
        indeterminate = 0xFFFFFFFF
    };
\end{lstlisting}

enum也不是一无是处，有时候专门用来做隐式转换，写起来更简单。
\begin{lstlisting}[language=C++]
    using UserInfo = std::tuple<std::string, std::string,  std::size_t> ; // name, email, reputation
    enum UserInfoFields { name, email, reputation };
    UserInfo uInfo; 
    auto val = std::get<email>(uInfo); // 相当于std::get<1>(uInfo)
\end{lstlisting}

enum class其实也可以做这种转换，需要事先写好constexpr函数方便这种转换。
\begin{lstlisting}[language=C++]
    template<typename E> // C++14
    constexpr auto
    toUType(E enumerator) noexcept
    {
        return static_cast<std::underlying_type_t<E>>(enumerator);
    }
    //还是比enum长，但是避免了namespace污染。
    auto val = std::get<toUType(UserInfoFields::email)>(uInfo);
\end{lstlisting}

